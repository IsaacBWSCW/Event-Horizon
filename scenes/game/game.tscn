[gd_scene load_steps=4 format=3 uid="uid://d0nmbsuxmb22o"]

[sub_resource type="Shader" id="Shader_sul5r"]
code = "shader_type canvas_item;

// FNVâ€‘1a inspired integer hash
uint hash1(uint x) {
	uint h = x;
	h ^= h >> 16u;
	h *= 0x7FEB352Du;
	h ^= h >> 15u;
	h *= 0x846CA68Bu;
	h ^= h >> 16u;
	return h;
}

uint hash3(uvec3 v, uint seed) {
	uint h = seed;
	h = hash1(h ^ v.x);
	h = hash1(h ^ v.y);
	h = hash1(h ^ v.z);
	return h;
}

vec3 grad3(uint h) {
	const vec3 grads[12] = vec3[12](
		vec3(1, 1, 0), vec3(-1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0),
		vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
		vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, 1, -1), vec3(0, -1, -1)
	);
	return normalize(grads[h & 0xFu]);
}

float fade(float t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlin3d_seeded(vec3 pos, uint seed) {
	ivec3 Pi = ivec3(floor(pos));
	vec3 Pf = fract(pos);
	vec3 u = vec3(fade(Pf.x), fade(Pf.y), fade(Pf.z));

	float accum = 0.0;
	for (int dz = 0; dz < 2; dz++) {
		for (int dy = 0; dy < 2; dy++) {
			for (int dx = 0; dx < 2; dx++) {
				uvec3 lattice = uvec3(Pi + ivec3(dx, dy, dz));
				uint h = hash3(lattice, seed);
				vec3 g = grad3(h);
				vec3 d = Pf - vec3(float(dx), float(dy), float(dz));
				float dotv = dot(g, d);
				vec3 w = vec3(dx != 0 ? u.x : 1.0 - u.x,
							  dy != 0 ? u.y : 1.0 - u.y,
							  dz != 0 ? u.z : 1.0 - u.z);
				accum += dotv * w.x * w.y * w.z;
			}
		}
	}
	return clamp(accum + 0.5, 0.0, 1.0);
}

float perlin_fbm(vec3 P, uint seed, uint octaves, float lacunarity, float gain) {
	float total = 0.0;
	float amplitude = 1.0;
	float frequency = 1.0;
	float maxAmplitude = (1.0 - pow(gain, float(octaves))) / (1.0 - gain);

	for (uint i = 0u; i < octaves; i++) {
		total += perlin3d_seeded(P * frequency, seed + i) * amplitude;

		frequency *= lacunarity;
		amplitude *= gain;
	}

	return total / maxAmplitude;
}

float distanceSquared(vec2 a, vec2 b) {
	vec2 d = a - b;
	return dot(d,d);
}

void fragment() {
	vec2 uvPixel = floor(UV * 2000.0 + 0.5) / 2000.0;

	if (distanceSquared(uvPixel, vec2(0.5, 0.5)) >= 0.25) {
		COLOR = vec4(0.0);
	} else {
		float time = floor(TIME * 12.0) / 12.0 / 50.0;
		//float time = TIME / 50.0;

		// Base turbulence
		float turbulence_scale = 32.0;
		float offset_scale = 10.0;
		vec2 uv_offset = vec2(
			perlin_fbm(vec3(uvPixel * turbulence_scale, time), 1, 8, 2.0, 0.5),
			perlin_fbm(vec3(uvPixel * turbulence_scale, time), 2, 8, 2.0, 0.5)
		);
		vec2 uv = uvPixel * turbulence_scale + (uv_offset * offset_scale);
		float n = perlin_fbm(vec3(uv, time), 0, 8, 2.0, 0.5);

		// Multi-color gradient (sun body)
		vec3 color;
		if (n < 0.25) {
			color = mix(vec3(0.6, 0.0, 0.0), vec3(1.0, 0.2, 0.0), n * 4.0);
		} else if (n < 0.5) {
			color = mix(vec3(1.0, 0.2, 0.0), vec3(1.0, 0.7, 0.0), (n - 0.25) * 4.0);
		} else if (n < 0.75) {
			color = mix(vec3(1.0, 0.7, 0.0), vec3(1.0, 1.0, 0.2), (n - 0.5) * 4.0);
		} else {
			color = mix(vec3(1.0, 1.0, 0.2), vec3(1.0, 1.0, 1.0), (n - 0.75) * 4.0);
		}
		color = floor(color * 4.0) / 4.0;

		float sunspot_mask = smoothstep(0.2, 0.21, perlin_fbm(vec3(uvPixel * 100.0, time / 4.0), 3, 4, 2.0, 0.65));
		float sunspot_ring_mask = smoothstep(0.28, 0.29, perlin_fbm(vec3(uvPixel * 100.0, time / 4.0), 3, 4, 2.0, 0.5));
		color = mix(mix(color, vec3(1.0, 0.5, 0.0), 0.65), color, sunspot_ring_mask);
		color *= vec3(sunspot_mask);

		COLOR = vec4(color, 1.0);
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_7h61r"]
shader = SubResource("Shader_sul5r")

[sub_resource type="PlaceholderTexture2D" id="PlaceholderTexture2D_bdhmt"]
size = Vector2(4, 4)

[node name="Game" type="Node2D"]

[node name="Bodies" type="Node2D" parent="."]
visible = false

[node name="Sun" type="Node2D" parent="Bodies"]
visible = false

[node name="Sprite2D" type="Sprite2D" parent="Bodies/Sun"]
visible = false
material = SubResource("ShaderMaterial_7h61r")
scale = Vector2(1000, 1000)
texture = SubResource("PlaceholderTexture2D_bdhmt")
