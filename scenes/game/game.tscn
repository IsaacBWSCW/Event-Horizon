[gd_scene load_steps=13 format=3 uid="uid://d0nmbsuxmb22o"]

[ext_resource type="Texture2D" uid="uid://tf6cp5bhxsyp" path="res://assets/ship.png" id="2_7h61r"]

[sub_resource type="GDScript" id="GDScript_sul5r"]
script/source = "extends RigidBody2D

func _physics_process(delta: float) -> void:
	angular_velocity = 0
	if Input.is_action_pressed(\"ship_turn_left\"):
		rotation += -1 * delta * TAU
	if Input.is_action_pressed(\"ship_turn_right\"):
		rotation += 1 * delta * TAU
	if Input.is_action_pressed(\"ship_thrust\"):
		linear_velocity += Vector2.from_angle(rotation - PI/2) * 50 * delta

#func _draw() -> void:
	#var points = []
	#var colors = []
	#var segments: int = 360
	#
	#for i in range(segments + 1):
		#var theta: float = TAU * i / segments
		#if abs(wrapf(theta - orbit.argument_of_periapsis, -PI, PI)) > orbit.get_angle_max():
			#continue
		#var dst: float = orbit.get_radius(theta)
		#var x: float = dst * cos(theta)
		#var y: float = dst * sin(theta)
		#var color = Color.RED
		#var point := Vector2(x, y)
		#if orbit_target:
			#point += orbit_target.global_position
		#points.append((point - global_position).rotated(-rotation))
		#colors.append(color)
		#
	#draw_polyline_colors(points, colors, 1.0, true)
"

[sub_resource type="CircleShape2D" id="CircleShape2D_ifgtf"]

[sub_resource type="GDScript" id="GDScript_0sr1o"]
script/source = "extends Camera2D

var zoom_step := 0.1
var min_zoom := 0.25
var max_zoom := 5.0

func _unhandled_input(event: InputEvent) -> void:
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			zoom *= 1.0 + zoom_step
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			zoom /= 1.0 + zoom_step
		zoom.x = clamp(zoom.x, min_zoom, max_zoom)
		zoom.y = clamp(zoom.y, min_zoom, max_zoom)
"

[sub_resource type="Shader" id="Shader_sul5r"]
code = "shader_type canvas_item;

// FNVâ€‘1a inspired integer hash
uint hash1(uint x) {
	uint h = x;
	h ^= h >> 16u;
	h *= 0x7FEB352Du;
	h ^= h >> 15u;
	h *= 0x846CA68Bu;
	h ^= h >> 16u;
	return h;
}

uint hash3(uvec3 v, uint seed) {
	uint h = seed;
	h = hash1(h ^ v.x);
	h = hash1(h ^ v.y);
	h = hash1(h ^ v.z);
	return h;
}

vec3 grad3(uint h) {
	const vec3 grads[12] = vec3[12](
		vec3(1, 1, 0), vec3(-1, 1, 0), vec3(1, -1, 0), vec3(-1, -1, 0),
		vec3(1, 0, 1), vec3(-1, 0, 1), vec3(1, 0, -1), vec3(-1, 0, -1),
		vec3(0, 1, 1), vec3(0, -1, 1), vec3(0, 1, -1), vec3(0, -1, -1)
	);
	return normalize(grads[h & 0xFu]);
}

float fade(float t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlin3d_seeded(vec3 pos, uint seed) {
	ivec3 Pi = ivec3(floor(pos));
	vec3 Pf = fract(pos);
	vec3 u = vec3(fade(Pf.x), fade(Pf.y), fade(Pf.z));

	float accum = 0.0;
	for (int dz = 0; dz < 2; dz++) {
		for (int dy = 0; dy < 2; dy++) {
			for (int dx = 0; dx < 2; dx++) {
				uvec3 lattice = uvec3(Pi + ivec3(dx, dy, dz));
				uint h = hash3(lattice, seed);
				vec3 g = grad3(h);
				vec3 d = Pf - vec3(float(dx), float(dy), float(dz));
				float dotv = dot(g, d);
				vec3 w = vec3(dx != 0 ? u.x : 1.0 - u.x,
							  dy != 0 ? u.y : 1.0 - u.y,
							  dz != 0 ? u.z : 1.0 - u.z);
				accum += dotv * w.x * w.y * w.z;
			}
		}
	}
	return clamp(accum + 0.5, 0.0, 1.0);
}

float perlin_fbm(vec3 P, uint seed, uint octaves, float lacunarity, float gain) {
	float total = 0.0;
	float amplitude = 1.0;
	float frequency = 1.0;
	float maxAmplitude = (1.0 - pow(gain, float(octaves))) / (1.0 - gain);

	for (uint i = 0u; i < octaves; i++) {
		total += perlin3d_seeded(P * frequency, seed + i) * amplitude;

		frequency *= lacunarity;
		amplitude *= gain;
	}

	return total / maxAmplitude;
}

void fragment() {
	if (distance(UV, vec2(0.5, 0.5)) > 0.5) {
		COLOR = vec4(0.0);
	} else {
		float time = TIME / 10.0;

		// Base turbulence
		float turbulence_scale = 1000.0;
		float offset_scale = 10.0;
		vec2 uv_offset = vec2(
			perlin_fbm(vec3(UV * turbulence_scale, time), 1, 8, 2.0, 0.5),
			perlin_fbm(vec3(UV * turbulence_scale, time), 2, 8, 2.0, 0.5)
		);
		vec2 uv = UV * turbulence_scale + (uv_offset * offset_scale);
		float n = perlin_fbm(vec3(uv, time), 0, 8, 2.0, 0.5);

		// Multi-color gradient (sun body)
		vec3 color;
		if (n < 0.25) {
			color = mix(vec3(0.6, 0.0, 0.0), vec3(1.0, 0.2, 0.0), n * 4.0);
		} else if (n < 0.5) {
			color = mix(vec3(1.0, 0.2, 0.0), vec3(1.0, 0.7, 0.0), (n - 0.25) * 4.0);
		} else if (n < 0.75) {
			color = mix(vec3(1.0, 0.7, 0.0), vec3(1.0, 1.0, 0.2), (n - 0.5) * 4.0);
		} else {
			color = mix(vec3(1.0, 1.0, 0.2), vec3(1.0, 1.0, 1.0), (n - 0.75) * 4.0);
		}

		float sunspot_mask = smoothstep(0.2, 0.21, perlin_fbm(vec3(UV * 100.0, time / 4.0), 3, 4, 2.0, 0.65));
		float sunspot_ring_mask = smoothstep(0.28, 0.29, perlin_fbm(vec3(UV * 100.0, time / 4.0), 3, 4, 2.0, 0.5));
		color = mix(mix(color, vec3(1.0, 0.5, 0.0), 0.65), color, sunspot_ring_mask);
		color *= vec3(sunspot_mask);

		COLOR = vec4(color, 1.0);
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_7h61r"]
shader = SubResource("Shader_sul5r")

[sub_resource type="PlaceholderTexture2D" id="PlaceholderTexture2D_bdhmt"]
size = Vector2(4, 4)

[sub_resource type="CircleShape2D" id="CircleShape2D_sul5r"]
radius = 1000.0

[sub_resource type="Gradient" id="Gradient_sul5r"]
interpolation_mode = 2
colors = PackedColorArray(1, 1, 1, 1, 1, 1, 1, 1)

[sub_resource type="GradientTexture2D" id="GradientTexture2D_7h61r"]
gradient = SubResource("Gradient_sul5r")
width = 4096
height = 4096
fill = 1
fill_from = Vector2(0.5, 0.5)
metadata/_snap_enabled = true
metadata/_snap_count = 2

[sub_resource type="CircleShape2D" id="CircleShape2D_7h61r"]

[sub_resource type="OccluderPolygon2D" id="OccluderPolygon2D_sul5r"]
polygon = PackedVector2Array(-9, -3, 6, -8, 6, 8, -1.74672, 2.31907)

[node name="Game" type="Node2D"]

[node name="CanvasModulate" type="CanvasModulate" parent="."]
color = Color(0, 0, 0, 1)

[node name="PlayerShip" type="RigidBody2D" parent="."]
position = Vector2(1152, 0)
script = SubResource("GDScript_sul5r")

[node name="CollisionShape2D" type="CollisionShape2D" parent="PlayerShip"]
shape = SubResource("CircleShape2D_ifgtf")

[node name="Sprite2D" type="Sprite2D" parent="PlayerShip"]
texture_filter = 1
position = Vector2(0, -2)
scale = Vector2(0.5, 0.5)
texture = ExtResource("2_7h61r")

[node name="Camera2D" type="Camera2D" parent="PlayerShip"]
script = SubResource("GDScript_0sr1o")

[node name="Bodies" type="Node2D" parent="."]

[node name="Sun" type="AnimatableBody2D" parent="Bodies"]

[node name="Sprite2D" type="Sprite2D" parent="Bodies/Sun"]
material = SubResource("ShaderMaterial_7h61r")
scale = Vector2(500, 500)
texture = SubResource("PlaceholderTexture2D_bdhmt")

[node name="CollisionShape2D" type="CollisionShape2D" parent="Bodies/Sun"]
visible = false
shape = SubResource("CircleShape2D_sul5r")

[node name="PointLight2D" type="PointLight2D" parent="Bodies/Sun"]
position = Vector2(-52, -48)
shadow_enabled = true
texture = SubResource("GradientTexture2D_7h61r")

[node name="ShadowTest" type="AnimatableBody2D" parent="Bodies"]
position = Vector2(1081, 0)

[node name="CollisionShape2D" type="CollisionShape2D" parent="Bodies/ShadowTest"]
shape = SubResource("CircleShape2D_7h61r")

[node name="LightOccluder2D" type="LightOccluder2D" parent="Bodies/ShadowTest"]
occluder = SubResource("OccluderPolygon2D_sul5r")
